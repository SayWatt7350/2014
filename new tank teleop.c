#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Hubs,  S2, HTMotor,  HTServo,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C1_1,     elevator1,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     elevator2,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     LeftFront,     tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     LeftBack,      tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S2_C1_1,     RightFront,    tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S2_C1_2,     RightBack,     tmotorTetrix, openLoop, encoder)
#pragma config(Servo,  srvo_S1_C3_1,    frontRS,              tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    backRS,               tServoStandard)
#pragma config(Servo,  srvo_S1_C3_3,    leftmandible,         tServoStandard)
#pragma config(Servo,  srvo_S1_C3_4,    rightmandible,        tServoStandard)
#pragma config(Servo,  srvo_S1_C3_5,    basketlifter,         tServoStandard)
#pragma config(Servo,  srvo_S1_C3_6,    score,                tServoStandard)
#pragma config(Servo,  srvo_S2_C2_1,    lock,              tServoStandard)//temporary
#pragma config(Servo,  srvo_S2_C2_2,    backLS,               tServoStandard)
#pragma config(Servo,  srvo_S2_C2_3,    gate,                 tServoStandard)
#pragma config(Servo,  srvo_S2_C2_4,    bad,                 tServoStandard)//temporary
#pragma config(Servo,  srvo_S2_C2_5,    servo11,              tServoNone)
#pragma config(Servo,  srvo_S2_C2_6,    servo12,              tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//#pragma config(Servo,  srvo_S2_C2_1,    frontLS,              tServoStandard)//temporary
//#pragma config(Servo,  srvo_S2_C2_4,    lock,                 tServoStandard)//bad
//constants for scaleForMotor function
const int DEADZONE = 25;
const int MAX_MOTOR_VAL = 100;
const float MAX_JOY_VAL = 127.0;
//frontleft
//backleft
//
//servo values
const int frontRS180 = 135;
const int backRS180 = 129;
const int frontLS180 = 134;
const int backLS180 = 138;

const int frontRS45 = 86;
const int backRS45 = 150;
const int frontLS45 = 106;
const int backLS45 = 166;


int scaleForMotor(int joyVal) //taken from l0jec's post on http://www.chiefdelphi.com/forums/archive/index.php/t-78636.html
{//this is an exponential drive



	//check for deadzone
	if(abs(joyVal) < DEADZONE) {
		return 0;
	}

	//calculate scaled value
	int sign = joyVal / abs(joyVal); // 1 or -1
	float ratio = ((joyVal * joyVal) / (MAX_JOY_VAL * MAX_JOY_VAL));
	int scaledVal = (sign * MAX_MOTOR_VAL) * ratio;

	return scaledVal;
}


#include "JoystickDriver.c"
task main()
{
	int threshold = 20;
	int servoangle=0;//for control of all servos
	/*int sa1;//for individual control of servo
	int sa2;
	int sa3;
	int sa4;
	*/
	int FWDval;//forard motion of the robot
	int LRval;//left/right motion of the robot
	int RCWval;//rotational value of the robot

	int A;//calculations for the swerve drive
	int B;
	int C;
	int D;

	int L=18;//length of robot
	int W=18;//width of robot
	int R=sqrt(L^2+W^2); //center of robot

	/*//removed for testing
	servo[frontRS]= 59;
	servo[backRS]= 81;
	servo[frontLS]= 122;
	servo[backLS]= 118;
	servo[Winch]=127;
	*/
	//  mandible servo positions
	//
	int openwideR = 250;
	int openwideL = 6;
	int shutR = 90;
	int shutL = 137;
	//  basket
	int basketup=50;
	int basketdown=165;
	//
	int elevatorposition=0;
	int uppositionscore=62;
	int downpositionscore= 5;
	// gate
	int gateup = 5;
	int gatedown = 250;
	//
	int lockup = 250;
	int lockdown = 0;
	//
	int scoreopen = 5;
	int scoreclose = 245;

	//    servo initialization
	servo[leftmandible] = openwideL;
	servo[rightmandible] = openwideR;
	servo[basketlifter] = basketup;
	servo[score] = scoreclose;
//	servo[lock] = lockup;
//	servo[gate] = gateup;
/*
	servo[frontRS] = frontRS180;
	servo[backRS] = backRS180;
	servo[frontLS] = frontLS180;
	servo[backLS] = backLS180;
*/
	waitForStart();
	while(true)
	{
				getJoystickSettings(joystick); //Constantly updates values on the joystick
		//Right Wheel
		if(abs(joystick.joy1_y2) > threshold)
		{
		motor[RightFront] = joystick.joy1_y2;//makes right side go forward
		motor[RightBack] = joystick.joy1_y2;
		}
		else
		{
		motor[RightFront] = 0;//stops right side
		motor[RightBack] = 0;
		}
		//Left wheel
		if (abs(joystick.joy1_y1) > threshold)
		{
		motor[LeftFront] = joystick.joy1_y1;//makes left side go forward
		motor[LeftBack] = joystick.joy1_y1;
		}
		else
		{
		motor[LeftFront] = 0;//stops left side
		motor[LeftBack] =0;
		}



		// Mandible controls
		if(joy1Btn(8))
		{

			servo[rightmandible] = shutR;
			servo[leftmandible] = shutL;
		}
		if(joy1Btn(6))
		{

			servo[rightmandible] = openwideR;
			servo[leftmandible] = openwideL;
		}

		// Mouth controls

		if(joy1Btn(4))
		{
			servo[basketlifter]=basketup;
			wait1Msec(30);

			servo[rightmandible] = openwideR;  // open mandibles so they don't hit elevator
			servo[leftmandible] = openwideL;
		}
		if(joy1Btn(2))
		{
			servo[basketlifter]=basketdown;
		}

		/////////////    JOYSTICK 2 //////////////////

		//  elevator controls

		if (joy2Btn(5))
		{
						motor[elevator1] = 100;
					motor[elevator2]=100;
		}
		else if (joy2Btn(7))
		{
					motor[elevator1] = -100;
			motor[elevator2]=-100;
		}
		else
		{
					motor[elevator1] = 0;
			motor[elevator2]=0;
		}

		// scoring

		if(joy2Btn(8))
		{

			servo[score] = scoreopen;
		}
		else
		{
			servo[score]=scoreclose;
		}

		// rolling goal

		if(joy2Btn(2))   // gate down to capture rolling goal
		{

			servo[gate] = gatedown;
		}

		if (joy2Btn(4))		// gate up
		{
			servo[lock]=250;
			//servo[lock] = lockup;
			//wait1Msec(5);
			//servo[gate] = gateup;

		}

		if (joy2Btn(3))		// lock on
		{
			servo[lock] = 250;//temporary
			//servo[lock] = lockdown;
		}

		if (joy2Btn(1))     // lock up - release rolling goal
		{
			servo[lock] = lockup;
		}


	}
}
