#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Hubs,  S2, HTMotor,  HTServo,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C1_1,     motorD,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     elevator,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     LeftFront,     tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     LeftBack,      tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S2_C1_1,     RightFront,    tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S2_C1_2,     RightBack,     tmotorTetrix, openLoop, encoder)
#pragma config(Servo,  srvo_S1_C3_1,    frontRS,              tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    backRS,               tServoStandard)
#pragma config(Servo,  srvo_S1_C3_3,    leftmandible,         tServoStandard)
#pragma config(Servo,  srvo_S1_C3_4,    rightmandible,        tServoStandard)
#pragma config(Servo,  srvo_S1_C3_5,    basketlifter,         tServoStandard)
#pragma config(Servo,  srvo_S1_C3_6,    score,                tServoStandard)
#pragma config(Servo,  srvo_S2_C2_1,    frontLS,              tServoStandard)
#pragma config(Servo,  srvo_S2_C2_2,    frontRS,              tServoStandard)
#pragma config(Servo,  srvo_S2_C2_3,    lock,                 tServoStandard)
#pragma config(Servo,  srvo_S2_C2_4,    gate,                 tServoStandard)
#pragma config(Servo,  srvo_S2_C2_5,    servo11,              tServoNone)
#pragma config(Servo,  srvo_S2_C2_6,    servo12,              tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//constants
const int DEADZONE = 25;
const int MAX_MOTOR_VAL = 100;
const float MAX_JOY_VAL = 127.0;


int scaleForMotor(int joyVal) //taken from l0jec's post on http://www.chiefdelphi.com/forums/archive/index.php/t-78636.html
{//this is an exponential drive



	//check for deadzone
	if(abs(joyVal) < DEADZONE) {
		return 0;
	}

	//calculate scaled value
	int sign = joyVal / abs(joyVal); // 1 or -1
	float ratio = ((joyVal * joyVal) / (MAX_JOY_VAL * MAX_JOY_VAL));
	int scaledVal = (sign * MAX_MOTOR_VAL) * ratio;

	return scaledVal;
}


#include "JoystickDriver.c"
task main()
{
	int threshold = 20;
	/*//removed for testing
	servo[frontRS]= 59;
	servo[backRS]= 81;
	servo[frontLS]= 122;
	servo[backLS]= 118;
	servo[Winch]=127;
	*/
	//  mandible servo positions
	//
	int openwideR = 250;
	int openwideL = 6;
	int shutR = 90;
	int shutL = 137;
	//  basket
	int basketup=48;
	int basketdown=173;
	//
	int elevatorposition=0;
	int uppositionscore=62;
	int downpositionscore= 5;
	// gate
	int gateup = 5;
	int gatedown = 250;
	//
	int lockup = 0;
	int lockdown = 85;
	//
	int scoreopen = 5;
	int scoreclose = 245;

	//    servo initialization
	servo[leftmandible] = openwideL;
	servo[rightmandible] = openwideR;
	servo[basketlifter] = basketup;
	servo[score] = scoreclose;
	servo[lock] = lockup;
	servo[gate] = gateup;


	waitForStart();
	while(true)
	{
		/*		getJoystickSettings(joystick); //Constantly updates values on the joystick
		//Right Wheel
		if(abs(joystick.joy1_y2) > threshold)
		{
		motor[RightFront] = joystick.joy1_y2;//makes right side go forward
		motor[RightBack] = joystick.joy1_y2;
		}
		else
		{
		motor[RightFront] = 0;//stops right side
		motor[RightBack] = 0;
		}
		//Left wheel
		if (abs(joystick.joy1_y1) > threshold)
		{
		motor[LeftFront] = joystick.joy1_y1;//makes left side go forward
		motor[LeftBack] = joystick.joy1_y1;
		}
		else
		{
		motor[LeftFront] = 0;//stops left side
		motor[LeftBack] =0;
		}
		*/

		motor[LeftFront] = scaleForMotor(joystick.joy1_y1);
		motor[LeftBack] = scaleForMotor(joystick.joy1_y1);

		if(joystick.joy1_y1>DEADZONE)
		{
			motor[LeftFront] = scaleForMotor(joystick.joy1_y1);
			motor[LeftBack] = scaleForMotor(joystick.joy1_y1);
			motor[RightFront] =  scaleForMotor(joystick.joy1_y1);
			motor[RightBack] =  scaleForMotor(joystick.joy1_y1);
		}

		// Mandible controls
		if(joy1Btn(8))
		{

			servo[rightmandible] = shutR;
			servo[leftmandible] = shutL;
		}
		if(joy1Btn(6))
		{

			servo[rightmandible] = openwideR;
			servo[leftmandible] = openwideL;
		}

		// Mouth controls

		if(joy1Btn(4))
		{
			servo[basketlifter]=basketup;
			wait1Msec(30);

			servo[rightmandible] = openwideR;  // open mandibles so they don't hit elevator
			servo[leftmandible] = openwideL;
		}
		if(joy1Btn(2))
		{
			servo[basketlifter]=basketdown;
		}

		/////////////    JOYSTICK 2 //////////////////

		//  elevator controls
		/*
		if(abs(joystick.joy2_y2) > threshold)// absolute value so can be negative or positive
		{
		motor[elevator] = 100*joystick.joy2_y2/abs(joystick.joy2_y2);//Raises the elevator
		}
		else
		{
		motor[elevator] = 0;
		}
		/*/
		if (joy2Btn(5))
		{
			motor[elevator] = 100;
		}
		else if (joy2Btn(7))
		{
			motor[elevator] = -100;
		}
		else
		{
			motor[elevator] = 0;
		}
		// scoring

		if(joy2Btn(8))
		{

			servo[score] = scoreopen;
		}
		else
		{
			servo[score]=scoreclose;
		}

		// rolling goal

		if(joy2Btn(2))   // gate down to capture rolling goal
		{

			servo[gate] = gatedown;
		}

		if (joy2Btn(4))		// gate up
		{
			servo[lock] = lockup;
			wait1Msec(5);
			servo[gate] = gateup;

		}

		if (joy2Btn(3))		// lock on
		{
			servo[lock] = lockdown;
		}

		if (joy2Btn(1))     // lock up - release rolling goal
		{
			servo[lock] = lockup;
		}


	}
}
