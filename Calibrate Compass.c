#pragma config(Hubs,  S1, HTMotor,  HTServo,  none,     none)
#pragma config(Hubs,  S2, HTMotor,  HTMotor,  HTServo,  HTServo)
#pragma config(Sensor, S3,     HTCOMPASS,         sensorI2CCustom)
#pragma config(Sensor, S4,     Mux,            sensorI2CCustom9V)
#pragma config(Motor,  mtr_S1_C1_1,     RightFront,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     RightBack,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C1_1,     elevator1,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C1_2,     elevator2,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C2_1,     LeftFront,     tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S2_C2_2,     LeftBack,      tmotorTetrix, openLoop, reversed)
#pragma config(Servo,  srvo_S1_C2_1,    frontRS,              tServoStandard)
#pragma config(Servo,  srvo_S1_C2_2,    backRS,               tServoStandard)
#pragma config(Servo,  srvo_S1_C2_3,    lock,                 tServoStandard)
#pragma config(Servo,  srvo_S1_C2_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_6,    servo6,               tServoNone)
#pragma config(Servo,  srvo_S2_C3_1,    frontLS,              tServoStandard)
#pragma config(Servo,  srvo_S2_C3_2,    backLS,               tServoStandard)
#pragma config(Servo,  srvo_S2_C3_3,    score,                tServoStandard)
#pragma config(Servo,  srvo_S2_C3_4,    servo10,              tServoNone)
#pragma config(Servo,  srvo_S2_C3_5,    servo11,              tServoNone)
#pragma config(Servo,  srvo_S2_C3_6,    servo12,              tServoNone)
#pragma config(Servo,  srvo_S2_C4_1,    leftmandible,         tServoStandard)
#pragma config(Servo,  srvo_S2_C4_2,    rightmandible,        tServoStandard)
#pragma config(Servo,  srvo_S2_C4_3,    mouth,                tServoStandard)
#pragma config(Servo,  srvo_S2_C4_4,    gate,                 tServoStandard)
#pragma config(Servo,  srvo_S2_C4_5,    servo23,              tServoNone)
#pragma config(Servo,  srvo_S2_C4_6,    servo24,              tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//



/*
* $Id: hitechnic-compass-test2.c 133 2013-03-10 15:15:38Z xander $
*/

/**
* hitechnic-compass.h provides an API for the HiTechnic Compass Sensor.  This program
* demonstrates how to use that API to calibrate the compass.
*
* The code here is made to work with the standard NXT Tribot.  You will need to edit
* the WHEELDIST, WHEELSIZE and MOTORSPEED figures to make it work with your robot.
*
* Remeber that the robot shouldn't spin more than 360 degrees per 20 seconds.  Also
* make sure it spins a bit more than 360, perhaps 1 and 1/4 or 1 and 1/2.
*
* Changelog:
* - 0.1: Initial release
* - 0.2: Added pulsating "*" to indicate progress
* - 0.3: More comments
*
* License: You may use this code as you wish, provided you give credit where it's due.
*
* THIS CODE WILL ONLY WORK WITH ROBOTC VERSION 3.59 AND HIGHER.

* Xander Soldaat (xander_at_botbench.com)
* 25 November 2009
* version 0.3
*/

#include "hitechnic-compass.h"




int speed = 50;//default motor speed
int fullspeed = 100;//motor speed variables



int sFRS = 90;//servo values
int sBRS = 109;
int sFLS = 132;
int sBLS = 131;

int straight_FRS = 161;
int straight_BRS = 154;
int straight_FLS = 132;
int straight_BLS = 131;


int FRS =0;
int BRS = 0;
int FLS  = 0;
int BLS = 0;

int lastservopos = 0;   // 1 = straight, 2 = spin , 3 = turn 45 deg to right, 4 = turn 45degrees to left, 5 = turn wheels to side









//
//   turnServos will turn the servos to one of five positions, then wait 150ms to adjust if lastpos is different then intended position.
//		turnpos =
//				1 = straight
//				2 = spin turn
//				3 = 45 degree angle to right
//				4 = 45 degree angle to left
//				5 = sideways
//

void turnServos(int turnpos, int lastpos)
{

		int FRStraight = 161;
		int BRStraight = 132;
		int FLStraight = 110;
		int BLStraight = 159;

		int FRLeft = 107;
		int BRLeft = 100;
		int FLLeft = 76;
		int BLLeft = 99;

		int FRRight = 219;
		int BRRight = 167;
		int FLRight = 144;
		int BLRight = 241;

		int FRSide = 49;
		int BRSide = 203;
		int FLSide = 179;
		int BLSide = 42;
/*
	servoChangeRate[RightFront]=1;
	servoChangeRate[LeftFront]=1;
	servoChangeRate[LeftBack]=1;
	servoChangeRate[RightBack]=1;
*/

	if (lastpos != turnpos)    // Only execute if the new position is different than the old position. otherwise return.
	{
		//   straight defaults
		// define temporary variables servo default is straight.
		int sFRS = 161;
		int sBRS = 154;
		int sFLS = 132;
		int sBLS = 131;

		//  Motors set to stop
		int mFRS =0;
		int mBRS = 0;
		int mFLS  = 0;
		int mBLS = 0;
		//
		// first, stop motors so don't create strain on servos.
		//
		motor[RightFront] = mFRS;
		motor[LeftFront] = mFLS;
		motor[RightBack] = mBRS;
		motor[LeftBack] = mBLS;


		switch (turnpos)
		{
		case 1:							// gostraight
			sFRS = FRStraight;
			sBRS = BRStraight;
			sFLS = FLStraight;
			sBLS = BLStraight;
			break;

		case 2:							// spin
			sFRS = FRLeft;				//   						\  	u
			sBRS = BRRight;				//  						/	 	u
			sFLS = FLRight;				//		/							u
			sBLS = BLLeft;				//		\							u
			// set motors direction to help servos and turn same direction as servo.
			if (lastpos == 1)  // straight to spin
			{
				mFRS = mBLS = -30;
				mFLS = mBLS = 30;
			} else if (lastpos == 5)  // sideways to spin
			{
				mFRS = mBLS = 30;
				mFLS = mBLS = -30;
			}

			break;

		case 3:				// 45 degree turn to right  ???
			sFRS = FRRight;				//   						/
			sBRS = BRRight;				//  						/
			sFLS = FLRight;				//		/
			sBLS = BLRight;				//	 ??? /
			break;


		case 4:				// 45 degree turn to left ???
			sFRS = FRLeft;				//   						\		u
			sBRS = BRLeft;				//  						\		u
			sFLS = FLLeft;				//		\							u
			sBLS = BLLeft;				//	  \							u
			break;

		case 5:				// sideways ???
			sFRS = FRSide;				//   						->
			sBRS = BRSide;				//  						->
			sFLS = FLSide;				//		->
			sBLS = BLSide;				//	  ->
			break;

		default:			// gostraight

			sFRS = FRStraight;
			sBRS = BRStraight;
			sFLS = FLStraight;
			sBLS = BLStraight;
			break;
		}   // end of switch

		// turn motor to help servo turn or leave it stopped
		motor[RightFront] = mFRS;
		motor[LeftFront] = mFLS;
		motor[RightBack] = mBRS;
		motor[LeftBack] = mBLS;

		//
		//  now turn servos
		//
		servo[frontRS]= sFRS;
		servo[backRS]= sBRS;
		servo[frontLS]= sFLS;
		servo[backLS]= sBLS;
		wait1Msec(150);		// only do this if changing servo pos.   if same as last time, then skip.

		//
		// Now, stop motors.  Will be restarted in new direction.
		//
		motor[RightFront] = 0;
		motor[LeftFront] = 0;
		motor[RightBack] = 0;
		motor[LeftBack] = 0;
	}

	lastpos = turnpos;
	return;
}


void turnright45()//turn 45 degrees right
{

	turnServos(2,lastservopos);
	int speed=50;
	int clicks=1440*3*PI/16;

	nMotorEncoder[RightBack] = 0;
	nMotorEncoder[RightFront] = 0;
	nMotorEncoder[LeftBack] = 0;
	nMotorEncoder[LeftFront] = 0;
	while(nMotorEncoder[RightBack] < clicks && nMotorEncoder[LeftFront] > -clicks)
	{
		motor[RightFront] = speed;
		motor[RightBack] = speed;
		motor[LeftFront] = -speed;
		motor[LeftBack] = -speed;
	}
	motor[RightFront] = 0;
	motor[RightBack] = 0;
	motor[LeftFront] = 0;
	motor[LeftBack] = 0;


}

void turnright90()//turn 90 degrees right
{
	turnServos(2,lastservopos);

	int speed=50;
	int clicks=1440*3*PI/8;

	nMotorEncoder[RightBack] = 0;
	nMotorEncoder[RightFront] = 0;
	nMotorEncoder[LeftBack] = 0;
	nMotorEncoder[LeftFront] = 0;
	while(nMotorEncoder[RightBack] < clicks && nMotorEncoder[LeftFront] < clicks)
	{
		motor[RightFront] = speed;
		motor[RightBack] = speed;
		motor[LeftFront] = -speed;
		motor[LeftBack] = -speed;
	}
	motor[RightFront] = 0;
	motor[RightBack] = 0;
	motor[LeftFront] = 0;
	motor[LeftBack] = 0;


}




void turnleft()//turn degrees left
{
//multiplying by 3/4 =450
//multiplying by 1 =720
	int speed=100;
	int clicks=((((1440*3)*(PI/8))/90))*3/4;

	nMotorEncoder[RightBack] = 0;

	while(nMotorEncoder[RightBack] < (clicks))
	{
		motor[RightFront] = speed;
		motor[RightBack] = speed;
		motor[LeftFront] = -speed;
		motor[LeftBack] = -speed;
	}
	motor[RightFront] = 0;
	motor[RightBack] = 0;
	motor[LeftFront] = 0;
	motor[LeftBack] = 0;


}








// Lets you know when 20 seconds is over, can help with setting up
// the initial timing and motor speed.
//task timeMe() {
//	wait1Msec(20000);
//	PlaySound(soundBeepBeep);
//	while(bSoundActive) EndTimeSlice();
//}

// Pulse a big "*" at the bottom of the screen to show that it's
// doing something.
task showPulse() {
	while (true) {
		nxtDisplayCenteredBigTextLine(6, " ");
		wait1Msec(400);
		nxtDisplayCenteredBigTextLine(6, "*");
		wait1Msec(400);
	}
}



// Start the calibration and complain loudly if something goes wrong
void startCalibration() {
	if (!HTMCstartCal(HTCOMPASS)) {
		eraseDisplay();
		nxtDisplayTextLine(1, "ERROR: Couldn't");
		nxtDisplayTextLine(2, "calibrate sensor.");
		nxtDisplayTextLine(4, "Check connection");
		nxtDisplayTextLine(5, "and try again.");
		PlaySound(soundException);
		while(bSoundActive) EndTimeSlice();
		wait1Msec(5000);
		StopAllTasks();
	}
}

// Stop the calibration and complain loudly if somethign goes wrong
void stopCalibration() {
	if (!HTMCstopCal(HTCOMPASS)) {
		eraseDisplay();
		nxtDisplayTextLine(1, "ERROR: Calibration");
		nxtDisplayTextLine(2, "has failed.");
		nxtDisplayTextLine(4, "Check connection");
		nxtDisplayTextLine(5, "and try again.");
		PlaySound(soundException);
		while(bSoundActive) EndTimeSlice();
		wait1Msec(5000);
		StopAllTasks();
		} else {
		nxtDisplayTextLine(1, "SUCCESS: ");
		nxtDisplayTextLine(2, "Calibr. done.");
		PlaySound(soundUpwardTones);
		while(bSoundActive) EndTimeSlice();
		wait1Msec(5000);
	}
}

task main () {

	bFloatDuringInactiveMotorPWM = false;
	turnServos(2,lastservopos);
	wait1Msec(2000);






	startCalibration();
	StartTask(showPulse);

	for(int x=0; x<180;x++)
	{
		turnleft();
		wait1Msec(111);

	}
	eraseDisplay();
	stopCalibration();




}

/*
* $Id: hitechnic-compass-test2.c 133 2013-03-10 15:15:38Z xander $
*/
