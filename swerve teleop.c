#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Hubs,  S2, HTMotor,  HTServo,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C1_1,     motorD,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     elevator,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     LeftFront,     tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     LeftBack,      tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S2_C1_1,     RightFront,    tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S2_C1_2,     RightBack,     tmotorTetrix, openLoop, encoder)
#pragma config(Servo,  srvo_S1_C3_1,    frontRS,              tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    backRS,               tServoStandard)
#pragma config(Servo,  srvo_S1_C3_3,    leftmandible,         tServoStandard)
#pragma config(Servo,  srvo_S1_C3_4,    rightmandible,        tServoStandard)
#pragma config(Servo,  srvo_S1_C3_5,    basketlifter,         tServoStandard)
#pragma config(Servo,  srvo_S1_C3_6,    score,                tServoStandard)
#pragma config(Servo,  srvo_S2_C2_1,    frontLS,              tServoStandard)
#pragma config(Servo,  srvo_S2_C2_2,    backLS,               tServoStandard)
#pragma config(Servo,  srvo_S2_C2_3,    lock,                 tServoStandard)
#pragma config(Servo,  srvo_S2_C2_4,    gate,                 tServoStandard)
#pragma config(Servo,  srvo_S2_C2_5,    servo11,              tServoNone)
#pragma config(Servo,  srvo_S2_C2_6,    servo12,              tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//constants for scaleForMotor function
const int DEADZONE = 25;
const int MAX_MOTOR_VAL = 100;
const float MAX_JOY_VAL = 127.0;
//frontleft
//backleft
//
//servo values
const int frontRS180 = 135;
const int backRS180 = 129;
const int frontLS180 = 134;
const int backLS180 = 138;

const int frontRS45 = 86;
const int backRS45 = 150;
const int frontLS45 = 106;
const int backLS45 = 166;


int scaleForMotor(int joyVal) //taken from l0jec's post on http://www.chiefdelphi.com/forums/archive/index.php/t-78636.html
{//this is an exponential drive



	//check for deadzone
	if(abs(joyVal) < DEADZONE) {
		return 0;
	}

	//calculate scaled value
	int sign = joyVal / abs(joyVal); // 1 or -1
	float ratio = ((joyVal * joyVal) / (MAX_JOY_VAL * MAX_JOY_VAL));
	int scaledVal = (sign * MAX_MOTOR_VAL) * ratio;

	return scaledVal;
}


#include "JoystickDriver.c"
task main()
{
	int threshold = 20;
	int servoangle=0;//for control of all servos
	/*int sa1;//for individual control of servo
	int sa2;
	int sa3;
	int sa4;
	*/
	int FWDval;//forard motion of the robot
	int LRval;//left/right motion of the robot
	int RCWval;//rotational value of the robot

	int A;//calculations for the swerve drive
	int B;
	int C;
	int D;

	int L=18;//length of robot
	int W=18;//width of robot
	int R=sqrt(L^2+W^2); //center of robot

	/*//removed for testing
	servo[frontRS]= 59;
	servo[backRS]= 81;
	servo[frontLS]= 122;
	servo[backLS]= 118;
	servo[Winch]=127;
	*/
	//  mandible servo positions
	//
	int openwideR = 250;
	int openwideL = 6;
	int shutR = 90;
	int shutL = 137;
	//  basket
	int basketup=48;
	int basketdown=173;
	//
	int elevatorposition=0;
	int uppositionscore=62;
	int downpositionscore= 5;
	// gate
	int gateup = 5;
	int gatedown = 250;
	//
	int lockup = 0;
	int lockdown = 85;
	//
	int scoreopen = 5;
	int scoreclose = 245;

	//    servo initialization
	servo[leftmandible] = openwideL;
	servo[rightmandible] = openwideR;
	servo[basketlifter] = basketup;
	servo[score] = scoreclose;
	servo[lock] = lockup;
	servo[gate] = gateup;

	servo[frontRS] = frontRS180;
	servo[backRS] = backRS180;
	servo[frontLS] = frontLS180;
	servo[backLS] = backLS180;

	waitForStart();
	while(true)
	{
		/*getJoystickSettings(joystick); //Constantly updates values on the joystick
		//Right Wheel
		if(abs(joystick.joy1_y2) > threshold)
		{
		motor[RightFront] = joystick.joy1_y2;//makes right side go forward
		motor[RightBack] = joystick.joy1_y2;
		}
		else
		{
		motor[RightFront] = 0;//stops right side
		motor[RightBack] = 0;
		}
		//Left wheel
		if (abs(joystick.joy1_y1) > threshold)
		{
		motor[LeftFront] = joystick.joy1_y1;//makes left side go forward
		motor[LeftBack] = joystick.joy1_y1;
		}
		else
		{
		motor[LeftFront] = 0;//stops left side
		motor[LeftBack] =0;
		}
		*/

		//		motor[LeftFront] = scaleForMotor(joystick.joy1_y1);
		//		motor[LeftBack] = scaleForMotor(joystick.joy1_y1);
		//distance from 0,0 is speed
		//angle is the ange of the servos


		if((abs(joystick.joy1_y1)>DEADZONE && abs(joystick.joy1_x1)>DEADZONE) &&
			/*this is so it doesn't go forward and rotate at the same time*/!(abs(joystick.joy1_x2)>DEADZONE))
		{
			/*
			triangle of joystick circlepad

			sqrt(joystick.joy1_y1^2 + joystick.joy1_x1^2)
			---------	/|
			-------- / |joystick.joy1_y1
			------- /  |
			------ /___|
			joystick.joy1_x1
			atan(abs(joystick.joy1_y1/joystick.joy1_x1))

			*/
			/*			servoangle=atan(abs(joystick.joy1_y1/joystick.joy1_x1));

			servo[frontRS] = servoangle;
			servo[backRS] = servoangle;
			servo[frontLS] = servoangle;
			servo[backLS] = servoangle;
			motor[LeftFront] = scaleForMotor(joystick.joy1_y2);
			motor[LeftBack] = scaleForMotor(joystick.joy1_y2);
			motor[RightFront] =  scaleForMotor(joystick.joy1_y2);
			motor[RightBack] =  scaleForMotor(joystick.joy1_y2);
			}
			else 	if(abs(joystick.joy1_x2)>DEADZONE &&  //only care about x value
			/*this is so it doesn't go forward and rotate at the same time*//*!(abs(joystick.joy1_y1)>DEADZONE && abs(joystick.joy1_x1)>DEADZONE))
			{
			servo[frontRS] = frontRS45;
			servo[backRS] = backRS45;
			servo[frontLS] = frontLS45;
			servo[backLS] = backLS45;
			motor[LeftFront] = -scaleForMotor(joystick.joy1_x2);
			motor[LeftBack] = -scaleForMotor(joystick.joy1_x2);
			motor[RightFront] =  scaleForMotor(joystick.joy1_x2);
			motor[RightBack] =  scaleForMotor(joystick.joy1_x2);
			}
			else */if(abs(joystick.joy1_x2)>DEADZONE && (abs(joystick.joy1_y1)>DEADZONE && abs(joystick.joy1_x1)>DEADZONE))
				//pseudocode for this was takedn from Ether on chief delphi
			//http://www.chiefdelphi.com/media/papers/2426
			{
				FWDval = -scaleForMotor(joystick.joy1_y2);
				LRval = scaleForMotor(joystick.joy1_x1);
				RCWval = scaleForMotor(joystick.joy1_x2);

				A = LRval -RCWval*(L/R);
				B = LRval +RCWval*(L/R);
				C =FWDval-RCWval*(W/R);
				D =FWDval+RCWval*(W/R);

				servo[frontRS] = sqrt(B^2+C^2);
				servo[frontLS] = sqrt(B^2+D^2);
				servo[backLS]  = sqrt(A^2+D^2);
				servo[backRS]  = sqrt(A^2+C^2);
				motor[RightFront] = atan2(B,C)*180/PI;
				motor[LeftFront] = atan2(B,D)*180/PI;
				motor[LeftBack] = atan2(A,D)*180/PI;
				motor[LeftFront] = atan2(A,C)*180/PI;

			}
			else
			{
				motor[LeftFront] = 0;
				motor[LeftBack] = 0;
				motor[RightFront] =  0;
				motor[RightBack] =  0;
			}

			// Mandible controls
			if(joy1Btn(8))
			{

				servo[rightmandible] = shutR;
				servo[leftmandible] = shutL;
			}
			if(joy1Btn(6))
			{

				servo[rightmandible] = openwideR;
				servo[leftmandible] = openwideL;
			}

			// Mouth controls

			if(joy1Btn(4))
			{
				servo[basketlifter]=basketup;
				wait1Msec(30);

				servo[rightmandible] = openwideR;  // open mandibles so they don't hit elevator
				servo[leftmandible] = openwideL;
			}
			if(joy1Btn(2))
			{
				servo[basketlifter]=basketdown;
			}

			/////////////    JOYSTICK 2 //////////////////

			//  elevator controls

			if (joy2Btn(5))
			{
				//			motor[elevator1] = 100;
				//		motor[elevator2]=100;
			}
			else if (joy2Btn(7))
			{
				//		motor[elevator1] = -100;
				//motor[elevator2]=-100;
			}
			else
			{
				motor[elevator] = 0;
			}

			// scoring

			if(joy2Btn(8))
			{

				servo[score] = scoreopen;
			}
			else
			{
				servo[score]=scoreclose;
			}

			// rolling goal

			if(joy2Btn(2))   // gate down to capture rolling goal
			{

				servo[gate] = gatedown;
			}

			if (joy2Btn(4))		// gate up
			{
				servo[lock] = lockup;
				wait1Msec(5);
				servo[gate] = gateup;

			}

			if (joy2Btn(3))		// lock on
			{
				servo[lock] = lockdown;
			}

			if (joy2Btn(1))     // lock up - release rolling goal
			{
				servo[lock] = lockup;
			}


		}
	}
}
