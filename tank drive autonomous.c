#pragma config(Hubs,  S1, HTMotor,  HTServo,  none,     none)
#pragma config(Hubs,  S2, HTMotor,  HTServo,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     colorPort,      sensorCOLORFULL)
#pragma config(Sensor, S4,     HTIRS2,         sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C1_1,     RightFront,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     RightBack,     tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S2_C1_1,     LeftFront,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C1_2,     LeftBack,      tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C2_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_3,    lift,                 tServoStandard)
#pragma config(Servo,  srvo_S1_C2_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_6,    servo6,               tServoNone)
#pragma config(Servo,  srvo_S2_C2_1,    servo7,               tServoNone)
#pragma config(Servo,  srvo_S2_C2_2,    servo8,               tServoNone)
#pragma config(Servo,  srvo_S2_C2_3,    servo9,               tServoNone)
#pragma config(Servo,  srvo_S2_C2_4,    servo10,              tServoNone)
#pragma config(Servo,  srvo_S2_C2_5,    servo11,              tServoNone)
#pragma config(Servo,  srvo_S2_C2_6,    servo12,              tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "hitechnic-irseeker-v2.h";//3rd party driver for the ir sensor
#include "joystickdriver.c"
const int COLOR_COUNT = 15;//the amount of colors we have
int speed = 50;//default motor speed
int fullspeed = 100;//motor speed variables

int colorTags[][] = {
	{254, 257, 138},//red
	{387, 390, 262},//light orange
	{331, 332, 170},//dark orange
	{346, 347, 298},//tan
	{217, 217, 172},//brown
	{390, 392, 345},//light yellow
	{374, 377, 311},//dark yellow
	{306, 310, 348},//light green
	{147, 158, 181},//dark green
	{194, 193, 265},//light blue
	{157, 161, 162},//dark blue
	{251, 248, 165},//purple
	{393, 396, 377},//white
	{375, 375, 177},//pink
	{79, 78, 80}//black
};

string colornames[15]={//declaration of all the names
	"Red",
	"Light Orange",
	"Dark Orange",
	"Tan",
	"Brown",
	"Light Yellow",
	"Dark Yellow",
	"Light Green",
	"Dark Green",
	"Light blue",
	"Dark blue",
	"Purple",
	"White",
	"Pink",
	"Black",
};


//END VARIABLE DECLARATIONS-------------------------------------------------------------
void turnleft90()//turn 90 degrees left
{
	int speed=50;
	int threshold=1440*3*PI/4;

	nMotorEncoder[RightBack] = 0;
	nMotorEncoder[RightFront] = 0;
	nMotorEncoder[LeftBack] = 0;
	nMotorEncoder[LeftFront] = 0;
	while(nMotorEncoder[RightBack] < threshold && nMotorEncoder[LeftFront] > -threshold)
	{
		motor[RightFront] = speed;
		motor[RightBack] = speed;
		motor[LeftFront] = -speed;
		motor[LeftBack] = -speed;
	}
	motor[RightFront] = 0;
	motor[RightBack] = 0;
	motor[LeftFront] = 0;
	motor[LeftBack] = 0;


}

void turnright45()//turn 45 degrees right
{
	int speed=50;
	int threshold=1440*3*PI/8;

	nMotorEncoder[RightBack] = 0;
	nMotorEncoder[RightFront] = 0;
	nMotorEncoder[LeftBack] = 0;
	nMotorEncoder[LeftFront] = 0;
	while(nMotorEncoder[RightBack] < threshold && nMotorEncoder[LeftFront] > -threshold)
	{
		motor[RightFront] = speed;
		motor[RightBack] = speed;
		motor[LeftFront] = -speed;
		motor[LeftBack] = -speed;
	}
	motor[RightFront] = 0;
	motor[RightBack] = 0;
	motor[LeftFront] = 0;
	motor[LeftBack] = 0;


}

void turnright90()//turn 90 degrees right
{
	int speed=50;
	int threshold=1440*3*PI/4;

	nMotorEncoder[RightBack] = 0;
	nMotorEncoder[RightFront] = 0;
	nMotorEncoder[LeftBack] = 0;
	nMotorEncoder[LeftFront] = 0;
	while(nMotorEncoder[RightBack] < threshold && nMotorEncoder[LeftFront] > -threshold)
	{
		motor[RightFront] = speed;
		motor[RightBack] = speed;
		motor[LeftFront] = -speed;
		motor[LeftBack] = -speed;
	}
	motor[RightFront] = 0;
	motor[RightBack] = 0;
	motor[LeftFront] = 0;
	motor[LeftBack] = 0;


}



void turnleft45()//turn 45 degrees left
{
	int speed=50;
	int threshold=1440*3*PI/8;

	nMotorEncoder[RightBack] = 0;
	nMotorEncoder[RightFront] = 0;
	nMotorEncoder[LeftBack] = 0;
	nMotorEncoder[LeftFront] = 0;
	while(nMotorEncoder[RightBack] > -threshold && nMotorEncoder[LeftFront] < threshold)
	{
		motor[RightFront] = -speed;
		motor[RightBack] = -speed;
		motor[LeftFront] = speed;
		motor[LeftBack] = speed;
	}
	motor[RightFront] = 0;
	motor[RightBack] = 0;
	motor[LeftFront] = 0;
	motor[LeftBack] = 0;


}

int gostraight(int distance)//go forward a certain distance
{
	int speed=50;
	int threshold=1440*3*PI*distance;//distance in inches? or centimeters?

	nMotorEncoder[RightBack] = 0;
	nMotorEncoder[RightFront] = 0;
	nMotorEncoder[LeftBack] = 0;
	nMotorEncoder[LeftFront] = 0;
	while(nMotorEncoder[RightFront] < threshold)
	{
		motor[RightFront] = speed;
		motor[RightBack] = speed;
		motor[LeftFront] = -speed;
		motor[LeftBack] = -speed;
	}
	motor[RightFront] = 0;
	motor[RightBack] = 0;
	motor[LeftFront] = 0;
	motor[LeftBack] = 0;

	return 0;

}

/*
Difference engine applies the difference formula onto two sets of RGB values
and returns the integer difference for comparison. Theory difference is
SQRT(Sum(distances squared))
*/
unsigned long thediff=0;//the difference between two values given to the function "difference"
void difference(long r1, long g1, long b1, long r2, long g2, long b2)
{
	long r = r1 - r2;//differences between database value and the scanned value
	long g = g1 - g2;
	long b = b1 - b2;

	thediff =sqrt(r^2+g^2+b^2);
}



void program1();
void program2();
void program15();

task main()
{

	//waitForStart();
	/*
	list of programs

	starting		|what to
	position		|do
	______________________________
	1		ramp		|knock down poles
	2		parking	|knock down poles
	3						|
	4						|
	5						|
	6						|
	7						|
	8						|
	10					|
	11					|
	12					|
	13					|
	14					|
	15	anywhere|go straight 5 seconds
	*/
wait1Msec(2000);
	disableDiagnosticsDisplay();
	short colorValues[4];//these are the scanned values

	int j;
	long r;
	long g;
	long b;
//	wait1Msec(500);

		int minDifference = 32767; // MAX_INT
	int selectedColor = 0;//this is the color closest to the scanned color



while(true)
{
	for(j =0; j<4; j++)//get color sensor values
	{
		getColorSensorData(colorPort, 0, &colorValues[j]);
		r = colorValues[0];
		g = colorValues[1];
		b = colorValues[2];
	}


	for(int i = 0; i < COLOR_COUNT; i++)//here we find the closest color in our database
	{

		difference(//passing in the database values and the scanned values to find the difference
		colorTags[i][0],
		colorTags[i][1],
		colorTags[i][2],
		r, g, b);
		long diff = thediff;

		if (diff <= minDifference) {//if the difference between the color in the database that we are currently checking and the scanned color
			minDifference = diff;			//is less than the smallest difference between the other database colors, then the database color we are
			selectedColor = i;				//currently checking is the closest match so far
		}

		nxtDisplayCenteredTextLine(0, "%d, %d", diff, minDifference);//print all the values
		nxtDisplayCenteredTextLine(1, "%d,%d,%d", colorValues[0], colorValues[1], colorValues[2]);
		nxtDisplayCenteredTextLine(4, "%d,%d,%d,",	colorTags[i][0], colorTags[i][1], colorTags[i][2]);
	}

	nxtDisplayCenteredTextLine(2, "%s", colornames[selectedColor]);
	nxtDisplayCenteredTextLine(3, "Is this the color?");
	if(nNxtButtonPressed==2)
	{
		break;
	}
}

	waitForStart();

	switch(selectedColor)
	{
	case 1:
		program1();
		break;
	case 2:
		program2();
		break;
		/*case 3:
		break;
		case 4:
		break;
		case 5:
		break;
		case 6:
		break;
		case 7:
		break;
		case 8:
		break;
		case 9:
		break;
		case 10:
		break;
		case 11:
		break;
		case 12:
		break;
		case 13:
		break;
		case 14:
		break;*/
	case 15:
		program15();
		break;
	default:
		program15();
		break;
	}

}


void program1()//first program
{

	int position = 2;//this is the position of the centerpiece. can be 1, 2, or 3
	//default is 2 because #2 routine works for positions 1 & 2
	int acS1, acS2, acS3, acS4, acS5;//irsensor values
	//	int acS1avg=0, acS2avg=0, acS3avg=0, acS4avg=0, acS5avg=0; //these were for testing the irsensor
	//	int prevacS1, prevacS2, prevacS3, prevacS4, prevacS5;			//these were for testing the irsensor
	int irthreshold=58.5;//to decide if position 3 or something else
	int irthreshold2=10;//to decide if position 2 or 1



	motor[RightFront] = speed;//get off the ramp
	motor[RightBack] = speed;
	motor[LeftFront] = speed;
	motor[LeftBack] = speed;
	wait1Msec(2600);

	HTIRS2readAllACStrength(HTIRS2,  acS1, acS2, acS3, acS4, acS5);//used to get ir sensor values

	if(acS4>irthreshold)//finding position of centerpiece
	{
		position=3;
	}
	else if(acS4>irthreshold2)
	{
		position=2;
	}
	else
	{
		position=1;
	}

	if(position==1 || position==2)
	{
		motor[RightFront] = speed;
		motor[RightBack] = speed;
		motor[LeftFront] = speed;
		motor[LeftBack] = speed;
		wait1Msec(500);

		turnleft45();


		motor[RightFront] = speed;
		motor[RightBack] = speed;
		motor[LeftFront] = speed;
		motor[LeftBack] = speed;
		wait1Msec(1500);

		turnleft45();

		motor[RightFront] = fullspeed;
		motor[RightBack] = fullspeed;
		motor[LeftFront] = fullspeed;
		motor[LeftBack] = fullspeed;
		wait1Msec(1000);

		turnleft45();//twist to knock down pole incase ramming it didn't work
	}
	else if(position == 3)//don't know if this works yet
	{
		turnleft90();


		motor[RightFront] = speed;
		motor[RightBack] = speed;
		motor[LeftFront] = speed;
		motor[LeftBack] = speed;
		wait1Msec(500);

		turnleft45();

		motor[RightFront] = speed;
		motor[RightBack] = speed;
		motor[LeftFront] = speed;
		motor[LeftBack] = speed;
		wait1Msec(1000);

		turnright45();

		motor[RightFront] = fullspeed;
		motor[RightBack] = fullspeed;
		motor[LeftFront] = fullspeed;
		motor[LeftBack] = fullspeed;
		wait1Msec(3000);

		turnleft45();


	}
}

void program2()//don't know if this works yet
{
	int position = 2;//this is the position of the centerpiece. can be 1, 2, or 3
	int acS1, acS2, acS3, acS4, acS5;//irsensor values
	//	int acS1avg=0, acS2avg=0, acS3avg=0, acS4avg=0, acS5avg=0; //these were for testing the irsensor
	//	int prevacS1, prevacS2, prevacS3, prevacS4, prevacS5;			//these were for testing the irsensor
	int irthreshold=58.5;//to decide if position 3 or something else
	int irthreshold2=10;//to decide if position 2 or 1



	HTIRS2readAllACStrength(HTIRS2,  acS1, acS2, acS3, acS4, acS5);//used to get ir sensor values

	if(acS4>irthreshold)//finding position of centerpiece
	{
		position=3;
	}
	else if(acS4>irthreshold2)
	{
		position=2;
	}
	else
	{
		position=1;
	}


	if(position==1)
	{
		motor[RightFront] = speed;
		motor[RightBack] = speed;
		motor[LeftFront] = speed;
		motor[LeftBack] = speed;
		wait1Msec(2000);

		turnright45();

		motor[RightFront] = speed;
		motor[RightBack] = speed;
		motor[LeftFront] = speed;
		motor[LeftBack] = speed;
		wait1Msec(500);

		turnleft45();

		motor[RightFront] = fullspeed;
		motor[RightBack] = fullspeed;
		motor[LeftFront] = fullspeed;
		motor[LeftBack] = fullspeed;
		wait1Msec(2000);

		turnright45();



	}
	else if(position == 2)
	{
		motor[RightFront] = speed;
		motor[RightBack] = speed;
		motor[LeftFront] = speed;
		motor[LeftBack] = speed;
		wait1Msec(2000);

		turnright45();

		motor[RightFront] = fullspeed;
		motor[RightBack] = fullspeed;
		motor[LeftFront] = fullspeed;
		motor[LeftBack] = fullspeed;
		wait1Msec(1000);

		turnright45();
	}
	else if(position == 3)
	{
		motor[RightFront] = fullspeed;
		motor[RightBack] = fullspeed;
		motor[LeftFront] = fullspeed;
		motor[LeftBack] = fullspeed;
		wait1Msec(3000);

		turnright45();
	}



}



void program15()
{
	motor[RightFront] = fullspeed;
	motor[RightBack] = fullspeed;
	motor[LeftFront] = fullspeed;
	motor[LeftBack] = fullspeed;
	wait1Msec(5000);

}
